// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Bitcoin.proto

#ifndef PROTOBUF_Bitcoin_2eproto__INCLUDED
#define PROTOBUF_Bitcoin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace opentxs {
namespace OTDB {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Bitcoin_2eproto();
void protobuf_AssignDesc_Bitcoin_2eproto();
void protobuf_ShutdownFile_Bitcoin_2eproto();

class BitcoinAcct_InternalPB;
class BitcoinServer_InternalPB;
class RippleServer_InternalPB;
class LoomServer_InternalPB;

// ===================================================================

class BitcoinAcct_InternalPB : public ::google::protobuf::MessageLite {
 public:
  BitcoinAcct_InternalPB();
  virtual ~BitcoinAcct_InternalPB();

  BitcoinAcct_InternalPB(const BitcoinAcct_InternalPB& from);

  inline BitcoinAcct_InternalPB& operator=(const BitcoinAcct_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BitcoinAcct_InternalPB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BitcoinAcct_InternalPB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BitcoinAcct_InternalPB* other);

  // implements Message ----------------------------------------------

  BitcoinAcct_InternalPB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BitcoinAcct_InternalPB& from);
  void MergeFrom(const BitcoinAcct_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string notary_id = 2;
  inline bool has_notary_id() const;
  inline void clear_notary_id();
  static const int kNotaryIdFieldNumber = 2;
  inline const ::std::string& notary_id() const;
  inline void set_notary_id(const ::std::string& value);
  inline void set_notary_id(const char* value);
  inline void set_notary_id(const char* value, size_t size);
  inline ::std::string* mutable_notary_id();
  inline ::std::string* release_notary_id();
  inline void set_allocated_notary_id(::std::string* notary_id);

  // optional string acct_id = 3;
  inline bool has_acct_id() const;
  inline void clear_acct_id();
  static const int kAcctIdFieldNumber = 3;
  inline const ::std::string& acct_id() const;
  inline void set_acct_id(const ::std::string& value);
  inline void set_acct_id(const char* value);
  inline void set_acct_id(const char* value, size_t size);
  inline ::std::string* mutable_acct_id();
  inline ::std::string* release_acct_id();
  inline void set_allocated_acct_id(::std::string* acct_id);

  // optional string bitcoin_acct_name = 4;
  inline bool has_bitcoin_acct_name() const;
  inline void clear_bitcoin_acct_name();
  static const int kBitcoinAcctNameFieldNumber = 4;
  inline const ::std::string& bitcoin_acct_name() const;
  inline void set_bitcoin_acct_name(const ::std::string& value);
  inline void set_bitcoin_acct_name(const char* value);
  inline void set_bitcoin_acct_name(const char* value, size_t size);
  inline ::std::string* mutable_bitcoin_acct_name();
  inline ::std::string* release_bitcoin_acct_name();
  inline void set_allocated_bitcoin_acct_name(::std::string* bitcoin_acct_name);

  // @@protoc_insertion_point(class_scope:opentxs.OTDB.BitcoinAcct_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_notary_id();
  inline void clear_has_notary_id();
  inline void set_has_acct_id();
  inline void clear_has_acct_id();
  inline void set_has_bitcoin_acct_name();
  inline void clear_has_bitcoin_acct_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gui_label_;
  ::std::string* notary_id_;
  ::std::string* acct_id_;
  ::std::string* bitcoin_acct_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Bitcoin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Bitcoin_2eproto();
  #endif
  friend void protobuf_AssignDesc_Bitcoin_2eproto();
  friend void protobuf_ShutdownFile_Bitcoin_2eproto();

  void InitAsDefaultInstance();
  static BitcoinAcct_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class BitcoinServer_InternalPB : public ::google::protobuf::MessageLite {
 public:
  BitcoinServer_InternalPB();
  virtual ~BitcoinServer_InternalPB();

  BitcoinServer_InternalPB(const BitcoinServer_InternalPB& from);

  inline BitcoinServer_InternalPB& operator=(const BitcoinServer_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BitcoinServer_InternalPB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BitcoinServer_InternalPB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BitcoinServer_InternalPB* other);

  // implements Message ----------------------------------------------

  BitcoinServer_InternalPB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BitcoinServer_InternalPB& from);
  void MergeFrom(const BitcoinServer_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string notary_id = 2;
  inline bool has_notary_id() const;
  inline void clear_notary_id();
  static const int kNotaryIdFieldNumber = 2;
  inline const ::std::string& notary_id() const;
  inline void set_notary_id(const ::std::string& value);
  inline void set_notary_id(const char* value);
  inline void set_notary_id(const char* value, size_t size);
  inline ::std::string* mutable_notary_id();
  inline ::std::string* release_notary_id();
  inline void set_allocated_notary_id(::std::string* notary_id);

  // optional string server_type = 3;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 3;
  inline const ::std::string& server_type() const;
  inline void set_server_type(const ::std::string& value);
  inline void set_server_type(const char* value);
  inline void set_server_type(const char* value, size_t size);
  inline ::std::string* mutable_server_type();
  inline ::std::string* release_server_type();
  inline void set_allocated_server_type(::std::string* server_type);

  // optional string server_host = 4;
  inline bool has_server_host() const;
  inline void clear_server_host();
  static const int kServerHostFieldNumber = 4;
  inline const ::std::string& server_host() const;
  inline void set_server_host(const ::std::string& value);
  inline void set_server_host(const char* value);
  inline void set_server_host(const char* value, size_t size);
  inline ::std::string* mutable_server_host();
  inline ::std::string* release_server_host();
  inline void set_allocated_server_host(::std::string* server_host);

  // optional string server_port = 5;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 5;
  inline const ::std::string& server_port() const;
  inline void set_server_port(const ::std::string& value);
  inline void set_server_port(const char* value);
  inline void set_server_port(const char* value, size_t size);
  inline ::std::string* mutable_server_port();
  inline ::std::string* release_server_port();
  inline void set_allocated_server_port(::std::string* server_port);

  // optional string bitcoin_username = 6;
  inline bool has_bitcoin_username() const;
  inline void clear_bitcoin_username();
  static const int kBitcoinUsernameFieldNumber = 6;
  inline const ::std::string& bitcoin_username() const;
  inline void set_bitcoin_username(const ::std::string& value);
  inline void set_bitcoin_username(const char* value);
  inline void set_bitcoin_username(const char* value, size_t size);
  inline ::std::string* mutable_bitcoin_username();
  inline ::std::string* release_bitcoin_username();
  inline void set_allocated_bitcoin_username(::std::string* bitcoin_username);

  // optional string bitcoin_password = 7;
  inline bool has_bitcoin_password() const;
  inline void clear_bitcoin_password();
  static const int kBitcoinPasswordFieldNumber = 7;
  inline const ::std::string& bitcoin_password() const;
  inline void set_bitcoin_password(const ::std::string& value);
  inline void set_bitcoin_password(const char* value);
  inline void set_bitcoin_password(const char* value, size_t size);
  inline ::std::string* mutable_bitcoin_password();
  inline ::std::string* release_bitcoin_password();
  inline void set_allocated_bitcoin_password(::std::string* bitcoin_password);

  // @@protoc_insertion_point(class_scope:opentxs.OTDB.BitcoinServer_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_notary_id();
  inline void clear_has_notary_id();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_host();
  inline void clear_has_server_host();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_bitcoin_username();
  inline void clear_has_bitcoin_username();
  inline void set_has_bitcoin_password();
  inline void clear_has_bitcoin_password();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gui_label_;
  ::std::string* notary_id_;
  ::std::string* server_type_;
  ::std::string* server_host_;
  ::std::string* server_port_;
  ::std::string* bitcoin_username_;
  ::std::string* bitcoin_password_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Bitcoin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Bitcoin_2eproto();
  #endif
  friend void protobuf_AssignDesc_Bitcoin_2eproto();
  friend void protobuf_ShutdownFile_Bitcoin_2eproto();

  void InitAsDefaultInstance();
  static BitcoinServer_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class RippleServer_InternalPB : public ::google::protobuf::MessageLite {
 public:
  RippleServer_InternalPB();
  virtual ~RippleServer_InternalPB();

  RippleServer_InternalPB(const RippleServer_InternalPB& from);

  inline RippleServer_InternalPB& operator=(const RippleServer_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RippleServer_InternalPB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RippleServer_InternalPB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RippleServer_InternalPB* other);

  // implements Message ----------------------------------------------

  RippleServer_InternalPB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RippleServer_InternalPB& from);
  void MergeFrom(const RippleServer_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string notary_id = 2;
  inline bool has_notary_id() const;
  inline void clear_notary_id();
  static const int kNotaryIdFieldNumber = 2;
  inline const ::std::string& notary_id() const;
  inline void set_notary_id(const ::std::string& value);
  inline void set_notary_id(const char* value);
  inline void set_notary_id(const char* value, size_t size);
  inline ::std::string* mutable_notary_id();
  inline ::std::string* release_notary_id();
  inline void set_allocated_notary_id(::std::string* notary_id);

  // optional string server_type = 3;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 3;
  inline const ::std::string& server_type() const;
  inline void set_server_type(const ::std::string& value);
  inline void set_server_type(const char* value);
  inline void set_server_type(const char* value, size_t size);
  inline ::std::string* mutable_server_type();
  inline ::std::string* release_server_type();
  inline void set_allocated_server_type(::std::string* server_type);

  // optional string server_host = 4;
  inline bool has_server_host() const;
  inline void clear_server_host();
  static const int kServerHostFieldNumber = 4;
  inline const ::std::string& server_host() const;
  inline void set_server_host(const ::std::string& value);
  inline void set_server_host(const char* value);
  inline void set_server_host(const char* value, size_t size);
  inline ::std::string* mutable_server_host();
  inline ::std::string* release_server_host();
  inline void set_allocated_server_host(::std::string* server_host);

  // optional string server_port = 5;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 5;
  inline const ::std::string& server_port() const;
  inline void set_server_port(const ::std::string& value);
  inline void set_server_port(const char* value);
  inline void set_server_port(const char* value, size_t size);
  inline ::std::string* mutable_server_port();
  inline ::std::string* release_server_port();
  inline void set_allocated_server_port(::std::string* server_port);

  // optional string ripple_username = 6;
  inline bool has_ripple_username() const;
  inline void clear_ripple_username();
  static const int kRippleUsernameFieldNumber = 6;
  inline const ::std::string& ripple_username() const;
  inline void set_ripple_username(const ::std::string& value);
  inline void set_ripple_username(const char* value);
  inline void set_ripple_username(const char* value, size_t size);
  inline ::std::string* mutable_ripple_username();
  inline ::std::string* release_ripple_username();
  inline void set_allocated_ripple_username(::std::string* ripple_username);

  // optional string ripple_password = 7;
  inline bool has_ripple_password() const;
  inline void clear_ripple_password();
  static const int kRipplePasswordFieldNumber = 7;
  inline const ::std::string& ripple_password() const;
  inline void set_ripple_password(const ::std::string& value);
  inline void set_ripple_password(const char* value);
  inline void set_ripple_password(const char* value, size_t size);
  inline ::std::string* mutable_ripple_password();
  inline ::std::string* release_ripple_password();
  inline void set_allocated_ripple_password(::std::string* ripple_password);

  // optional string namefield_id = 8;
  inline bool has_namefield_id() const;
  inline void clear_namefield_id();
  static const int kNamefieldIdFieldNumber = 8;
  inline const ::std::string& namefield_id() const;
  inline void set_namefield_id(const ::std::string& value);
  inline void set_namefield_id(const char* value);
  inline void set_namefield_id(const char* value, size_t size);
  inline ::std::string* mutable_namefield_id();
  inline ::std::string* release_namefield_id();
  inline void set_allocated_namefield_id(::std::string* namefield_id);

  // optional string passfield_id = 9;
  inline bool has_passfield_id() const;
  inline void clear_passfield_id();
  static const int kPassfieldIdFieldNumber = 9;
  inline const ::std::string& passfield_id() const;
  inline void set_passfield_id(const ::std::string& value);
  inline void set_passfield_id(const char* value);
  inline void set_passfield_id(const char* value, size_t size);
  inline ::std::string* mutable_passfield_id();
  inline ::std::string* release_passfield_id();
  inline void set_allocated_passfield_id(::std::string* passfield_id);

  // @@protoc_insertion_point(class_scope:opentxs.OTDB.RippleServer_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_notary_id();
  inline void clear_has_notary_id();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_host();
  inline void clear_has_server_host();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_ripple_username();
  inline void clear_has_ripple_username();
  inline void set_has_ripple_password();
  inline void clear_has_ripple_password();
  inline void set_has_namefield_id();
  inline void clear_has_namefield_id();
  inline void set_has_passfield_id();
  inline void clear_has_passfield_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gui_label_;
  ::std::string* notary_id_;
  ::std::string* server_type_;
  ::std::string* server_host_;
  ::std::string* server_port_;
  ::std::string* ripple_username_;
  ::std::string* ripple_password_;
  ::std::string* namefield_id_;
  ::std::string* passfield_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Bitcoin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Bitcoin_2eproto();
  #endif
  friend void protobuf_AssignDesc_Bitcoin_2eproto();
  friend void protobuf_ShutdownFile_Bitcoin_2eproto();

  void InitAsDefaultInstance();
  static RippleServer_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class LoomServer_InternalPB : public ::google::protobuf::MessageLite {
 public:
  LoomServer_InternalPB();
  virtual ~LoomServer_InternalPB();

  LoomServer_InternalPB(const LoomServer_InternalPB& from);

  inline LoomServer_InternalPB& operator=(const LoomServer_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoomServer_InternalPB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoomServer_InternalPB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoomServer_InternalPB* other);

  // implements Message ----------------------------------------------

  LoomServer_InternalPB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoomServer_InternalPB& from);
  void MergeFrom(const LoomServer_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string notary_id = 2;
  inline bool has_notary_id() const;
  inline void clear_notary_id();
  static const int kNotaryIdFieldNumber = 2;
  inline const ::std::string& notary_id() const;
  inline void set_notary_id(const ::std::string& value);
  inline void set_notary_id(const char* value);
  inline void set_notary_id(const char* value, size_t size);
  inline ::std::string* mutable_notary_id();
  inline ::std::string* release_notary_id();
  inline void set_allocated_notary_id(::std::string* notary_id);

  // optional string server_type = 3;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 3;
  inline const ::std::string& server_type() const;
  inline void set_server_type(const ::std::string& value);
  inline void set_server_type(const char* value);
  inline void set_server_type(const char* value, size_t size);
  inline ::std::string* mutable_server_type();
  inline ::std::string* release_server_type();
  inline void set_allocated_server_type(::std::string* server_type);

  // optional string server_host = 4;
  inline bool has_server_host() const;
  inline void clear_server_host();
  static const int kServerHostFieldNumber = 4;
  inline const ::std::string& server_host() const;
  inline void set_server_host(const ::std::string& value);
  inline void set_server_host(const char* value);
  inline void set_server_host(const char* value, size_t size);
  inline ::std::string* mutable_server_host();
  inline ::std::string* release_server_host();
  inline void set_allocated_server_host(::std::string* server_host);

  // optional string server_port = 5;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 5;
  inline const ::std::string& server_port() const;
  inline void set_server_port(const ::std::string& value);
  inline void set_server_port(const char* value);
  inline void set_server_port(const char* value, size_t size);
  inline ::std::string* mutable_server_port();
  inline ::std::string* release_server_port();
  inline void set_allocated_server_port(::std::string* server_port);

  // optional string loom_username = 6;
  inline bool has_loom_username() const;
  inline void clear_loom_username();
  static const int kLoomUsernameFieldNumber = 6;
  inline const ::std::string& loom_username() const;
  inline void set_loom_username(const ::std::string& value);
  inline void set_loom_username(const char* value);
  inline void set_loom_username(const char* value, size_t size);
  inline ::std::string* mutable_loom_username();
  inline ::std::string* release_loom_username();
  inline void set_allocated_loom_username(::std::string* loom_username);

  // optional string namefield_id = 7;
  inline bool has_namefield_id() const;
  inline void clear_namefield_id();
  static const int kNamefieldIdFieldNumber = 7;
  inline const ::std::string& namefield_id() const;
  inline void set_namefield_id(const ::std::string& value);
  inline void set_namefield_id(const char* value);
  inline void set_namefield_id(const char* value, size_t size);
  inline ::std::string* mutable_namefield_id();
  inline ::std::string* release_namefield_id();
  inline void set_allocated_namefield_id(::std::string* namefield_id);

  // @@protoc_insertion_point(class_scope:opentxs.OTDB.LoomServer_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_notary_id();
  inline void clear_has_notary_id();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_host();
  inline void clear_has_server_host();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_loom_username();
  inline void clear_has_loom_username();
  inline void set_has_namefield_id();
  inline void clear_has_namefield_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gui_label_;
  ::std::string* notary_id_;
  ::std::string* server_type_;
  ::std::string* server_host_;
  ::std::string* server_port_;
  ::std::string* loom_username_;
  ::std::string* namefield_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Bitcoin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Bitcoin_2eproto();
  #endif
  friend void protobuf_AssignDesc_Bitcoin_2eproto();
  friend void protobuf_ShutdownFile_Bitcoin_2eproto();

  void InitAsDefaultInstance();
  static LoomServer_InternalPB* default_instance_;
};
// ===================================================================


// ===================================================================

// BitcoinAcct_InternalPB

// optional string gui_label = 1;
inline bool BitcoinAcct_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BitcoinAcct_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BitcoinAcct_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& BitcoinAcct_InternalPB::gui_label() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
  return *gui_label_;
}
inline void BitcoinAcct_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
inline void BitcoinAcct_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
inline void BitcoinAcct_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
  return gui_label_;
}
inline ::std::string* BitcoinAcct_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinAcct_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool BitcoinAcct_InternalPB::has_notary_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_notary_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BitcoinAcct_InternalPB::clear_has_notary_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BitcoinAcct_InternalPB::clear_notary_id() {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_->clear();
  }
  clear_has_notary_id();
}
inline const ::std::string& BitcoinAcct_InternalPB::notary_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
  return *notary_id_;
}
inline void BitcoinAcct_InternalPB::set_notary_id(const ::std::string& value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
inline void BitcoinAcct_InternalPB::set_notary_id(const char* value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
inline void BitcoinAcct_InternalPB::set_notary_id(const char* value, size_t size) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_notary_id() {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
  return notary_id_;
}
inline ::std::string* BitcoinAcct_InternalPB::release_notary_id() {
  clear_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = notary_id_;
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinAcct_InternalPB::set_allocated_notary_id(::std::string* notary_id) {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete notary_id_;
  }
  if (notary_id) {
    set_has_notary_id();
    notary_id_ = notary_id;
  } else {
    clear_has_notary_id();
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}

// optional string acct_id = 3;
inline bool BitcoinAcct_InternalPB::has_acct_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_acct_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BitcoinAcct_InternalPB::clear_has_acct_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BitcoinAcct_InternalPB::clear_acct_id() {
  if (acct_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acct_id_->clear();
  }
  clear_has_acct_id();
}
inline const ::std::string& BitcoinAcct_InternalPB::acct_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
  return *acct_id_;
}
inline void BitcoinAcct_InternalPB::set_acct_id(const ::std::string& value) {
  set_has_acct_id();
  if (acct_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acct_id_ = new ::std::string;
  }
  acct_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
inline void BitcoinAcct_InternalPB::set_acct_id(const char* value) {
  set_has_acct_id();
  if (acct_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acct_id_ = new ::std::string;
  }
  acct_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
inline void BitcoinAcct_InternalPB::set_acct_id(const char* value, size_t size) {
  set_has_acct_id();
  if (acct_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acct_id_ = new ::std::string;
  }
  acct_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_acct_id() {
  set_has_acct_id();
  if (acct_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acct_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
  return acct_id_;
}
inline ::std::string* BitcoinAcct_InternalPB::release_acct_id() {
  clear_has_acct_id();
  if (acct_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = acct_id_;
    acct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinAcct_InternalPB::set_allocated_acct_id(::std::string* acct_id) {
  if (acct_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete acct_id_;
  }
  if (acct_id) {
    set_has_acct_id();
    acct_id_ = acct_id;
  } else {
    clear_has_acct_id();
    acct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}

// optional string bitcoin_acct_name = 4;
inline bool BitcoinAcct_InternalPB::has_bitcoin_acct_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_bitcoin_acct_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BitcoinAcct_InternalPB::clear_has_bitcoin_acct_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BitcoinAcct_InternalPB::clear_bitcoin_acct_name() {
  if (bitcoin_acct_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_acct_name_->clear();
  }
  clear_has_bitcoin_acct_name();
}
inline const ::std::string& BitcoinAcct_InternalPB::bitcoin_acct_name() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
  return *bitcoin_acct_name_;
}
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(const ::std::string& value) {
  set_has_bitcoin_acct_name();
  if (bitcoin_acct_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_acct_name_ = new ::std::string;
  }
  bitcoin_acct_name_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(const char* value) {
  set_has_bitcoin_acct_name();
  if (bitcoin_acct_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_acct_name_ = new ::std::string;
  }
  bitcoin_acct_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(const char* value, size_t size) {
  set_has_bitcoin_acct_name();
  if (bitcoin_acct_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_acct_name_ = new ::std::string;
  }
  bitcoin_acct_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_bitcoin_acct_name() {
  set_has_bitcoin_acct_name();
  if (bitcoin_acct_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_acct_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
  return bitcoin_acct_name_;
}
inline ::std::string* BitcoinAcct_InternalPB::release_bitcoin_acct_name() {
  clear_has_bitcoin_acct_name();
  if (bitcoin_acct_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bitcoin_acct_name_;
    bitcoin_acct_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinAcct_InternalPB::set_allocated_bitcoin_acct_name(::std::string* bitcoin_acct_name) {
  if (bitcoin_acct_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bitcoin_acct_name_;
  }
  if (bitcoin_acct_name) {
    set_has_bitcoin_acct_name();
    bitcoin_acct_name_ = bitcoin_acct_name;
  } else {
    clear_has_bitcoin_acct_name();
    bitcoin_acct_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}

// -------------------------------------------------------------------

// BitcoinServer_InternalPB

// optional string gui_label = 1;
inline bool BitcoinServer_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BitcoinServer_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BitcoinServer_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& BitcoinServer_InternalPB::gui_label() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
  return *gui_label_;
}
inline void BitcoinServer_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
inline void BitcoinServer_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
inline void BitcoinServer_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
  return gui_label_;
}
inline ::std::string* BitcoinServer_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool BitcoinServer_InternalPB::has_notary_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_notary_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BitcoinServer_InternalPB::clear_has_notary_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BitcoinServer_InternalPB::clear_notary_id() {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_->clear();
  }
  clear_has_notary_id();
}
inline const ::std::string& BitcoinServer_InternalPB::notary_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
  return *notary_id_;
}
inline void BitcoinServer_InternalPB::set_notary_id(const ::std::string& value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
inline void BitcoinServer_InternalPB::set_notary_id(const char* value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
inline void BitcoinServer_InternalPB::set_notary_id(const char* value, size_t size) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_notary_id() {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
  return notary_id_;
}
inline ::std::string* BitcoinServer_InternalPB::release_notary_id() {
  clear_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = notary_id_;
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_notary_id(::std::string* notary_id) {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete notary_id_;
  }
  if (notary_id) {
    set_has_notary_id();
    notary_id_ = notary_id;
  } else {
    clear_has_notary_id();
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}

// optional string server_type = 3;
inline bool BitcoinServer_InternalPB::has_server_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_server_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BitcoinServer_InternalPB::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BitcoinServer_InternalPB::clear_server_type() {
  if (server_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_->clear();
  }
  clear_has_server_type();
}
inline const ::std::string& BitcoinServer_InternalPB::server_type() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
  return *server_type_;
}
inline void BitcoinServer_InternalPB::set_server_type(const ::std::string& value) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
inline void BitcoinServer_InternalPB::set_server_type(const char* value) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
inline void BitcoinServer_InternalPB::set_server_type(const char* value, size_t size) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_server_type() {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
  return server_type_;
}
inline ::std::string* BitcoinServer_InternalPB::release_server_type() {
  clear_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_type_;
    server_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_server_type(::std::string* server_type) {
  if (server_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_type_;
  }
  if (server_type) {
    set_has_server_type();
    server_type_ = server_type;
  } else {
    clear_has_server_type();
    server_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}

// optional string server_host = 4;
inline bool BitcoinServer_InternalPB::has_server_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_server_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BitcoinServer_InternalPB::clear_has_server_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BitcoinServer_InternalPB::clear_server_host() {
  if (server_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_->clear();
  }
  clear_has_server_host();
}
inline const ::std::string& BitcoinServer_InternalPB::server_host() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
  return *server_host_;
}
inline void BitcoinServer_InternalPB::set_server_host(const ::std::string& value) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
inline void BitcoinServer_InternalPB::set_server_host(const char* value) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
inline void BitcoinServer_InternalPB::set_server_host(const char* value, size_t size) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_server_host() {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
  return server_host_;
}
inline ::std::string* BitcoinServer_InternalPB::release_server_host() {
  clear_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_host_;
    server_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_server_host(::std::string* server_host) {
  if (server_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_host_;
  }
  if (server_host) {
    set_has_server_host();
    server_host_ = server_host;
  } else {
    clear_has_server_host();
    server_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}

// optional string server_port = 5;
inline bool BitcoinServer_InternalPB::has_server_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_server_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BitcoinServer_InternalPB::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BitcoinServer_InternalPB::clear_server_port() {
  if (server_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_->clear();
  }
  clear_has_server_port();
}
inline const ::std::string& BitcoinServer_InternalPB::server_port() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
  return *server_port_;
}
inline void BitcoinServer_InternalPB::set_server_port(const ::std::string& value) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
inline void BitcoinServer_InternalPB::set_server_port(const char* value) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
inline void BitcoinServer_InternalPB::set_server_port(const char* value, size_t size) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_server_port() {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
  return server_port_;
}
inline ::std::string* BitcoinServer_InternalPB::release_server_port() {
  clear_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_port_;
    server_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_server_port(::std::string* server_port) {
  if (server_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_port_;
  }
  if (server_port) {
    set_has_server_port();
    server_port_ = server_port;
  } else {
    clear_has_server_port();
    server_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}

// optional string bitcoin_username = 6;
inline bool BitcoinServer_InternalPB::has_bitcoin_username() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_bitcoin_username() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BitcoinServer_InternalPB::clear_has_bitcoin_username() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BitcoinServer_InternalPB::clear_bitcoin_username() {
  if (bitcoin_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_username_->clear();
  }
  clear_has_bitcoin_username();
}
inline const ::std::string& BitcoinServer_InternalPB::bitcoin_username() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
  return *bitcoin_username_;
}
inline void BitcoinServer_InternalPB::set_bitcoin_username(const ::std::string& value) {
  set_has_bitcoin_username();
  if (bitcoin_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_username_ = new ::std::string;
  }
  bitcoin_username_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
inline void BitcoinServer_InternalPB::set_bitcoin_username(const char* value) {
  set_has_bitcoin_username();
  if (bitcoin_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_username_ = new ::std::string;
  }
  bitcoin_username_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
inline void BitcoinServer_InternalPB::set_bitcoin_username(const char* value, size_t size) {
  set_has_bitcoin_username();
  if (bitcoin_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_username_ = new ::std::string;
  }
  bitcoin_username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_bitcoin_username() {
  set_has_bitcoin_username();
  if (bitcoin_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
  return bitcoin_username_;
}
inline ::std::string* BitcoinServer_InternalPB::release_bitcoin_username() {
  clear_has_bitcoin_username();
  if (bitcoin_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bitcoin_username_;
    bitcoin_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_bitcoin_username(::std::string* bitcoin_username) {
  if (bitcoin_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bitcoin_username_;
  }
  if (bitcoin_username) {
    set_has_bitcoin_username();
    bitcoin_username_ = bitcoin_username;
  } else {
    clear_has_bitcoin_username();
    bitcoin_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}

// optional string bitcoin_password = 7;
inline bool BitcoinServer_InternalPB::has_bitcoin_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_bitcoin_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BitcoinServer_InternalPB::clear_has_bitcoin_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BitcoinServer_InternalPB::clear_bitcoin_password() {
  if (bitcoin_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_password_->clear();
  }
  clear_has_bitcoin_password();
}
inline const ::std::string& BitcoinServer_InternalPB::bitcoin_password() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
  return *bitcoin_password_;
}
inline void BitcoinServer_InternalPB::set_bitcoin_password(const ::std::string& value) {
  set_has_bitcoin_password();
  if (bitcoin_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_password_ = new ::std::string;
  }
  bitcoin_password_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
inline void BitcoinServer_InternalPB::set_bitcoin_password(const char* value) {
  set_has_bitcoin_password();
  if (bitcoin_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_password_ = new ::std::string;
  }
  bitcoin_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
inline void BitcoinServer_InternalPB::set_bitcoin_password(const char* value, size_t size) {
  set_has_bitcoin_password();
  if (bitcoin_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_password_ = new ::std::string;
  }
  bitcoin_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_bitcoin_password() {
  set_has_bitcoin_password();
  if (bitcoin_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bitcoin_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
  return bitcoin_password_;
}
inline ::std::string* BitcoinServer_InternalPB::release_bitcoin_password() {
  clear_has_bitcoin_password();
  if (bitcoin_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bitcoin_password_;
    bitcoin_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BitcoinServer_InternalPB::set_allocated_bitcoin_password(::std::string* bitcoin_password) {
  if (bitcoin_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bitcoin_password_;
  }
  if (bitcoin_password) {
    set_has_bitcoin_password();
    bitcoin_password_ = bitcoin_password;
  } else {
    clear_has_bitcoin_password();
    bitcoin_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}

// -------------------------------------------------------------------

// RippleServer_InternalPB

// optional string gui_label = 1;
inline bool RippleServer_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleServer_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RippleServer_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RippleServer_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& RippleServer_InternalPB::gui_label() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.gui_label)
  return *gui_label_;
}
inline void RippleServer_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
inline void RippleServer_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
inline void RippleServer_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
inline ::std::string* RippleServer_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.gui_label)
  return gui_label_;
}
inline ::std::string* RippleServer_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool RippleServer_InternalPB::has_notary_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RippleServer_InternalPB::set_has_notary_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RippleServer_InternalPB::clear_has_notary_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RippleServer_InternalPB::clear_notary_id() {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_->clear();
  }
  clear_has_notary_id();
}
inline const ::std::string& RippleServer_InternalPB::notary_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.notary_id)
  return *notary_id_;
}
inline void RippleServer_InternalPB::set_notary_id(const ::std::string& value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
inline void RippleServer_InternalPB::set_notary_id(const char* value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
inline void RippleServer_InternalPB::set_notary_id(const char* value, size_t size) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
inline ::std::string* RippleServer_InternalPB::mutable_notary_id() {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.notary_id)
  return notary_id_;
}
inline ::std::string* RippleServer_InternalPB::release_notary_id() {
  clear_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = notary_id_;
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_notary_id(::std::string* notary_id) {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete notary_id_;
  }
  if (notary_id) {
    set_has_notary_id();
    notary_id_ = notary_id;
  } else {
    clear_has_notary_id();
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}

// optional string server_type = 3;
inline bool RippleServer_InternalPB::has_server_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RippleServer_InternalPB::set_has_server_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RippleServer_InternalPB::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RippleServer_InternalPB::clear_server_type() {
  if (server_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_->clear();
  }
  clear_has_server_type();
}
inline const ::std::string& RippleServer_InternalPB::server_type() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.server_type)
  return *server_type_;
}
inline void RippleServer_InternalPB::set_server_type(const ::std::string& value) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
inline void RippleServer_InternalPB::set_server_type(const char* value) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
inline void RippleServer_InternalPB::set_server_type(const char* value, size_t size) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
inline ::std::string* RippleServer_InternalPB::mutable_server_type() {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.server_type)
  return server_type_;
}
inline ::std::string* RippleServer_InternalPB::release_server_type() {
  clear_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_type_;
    server_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_server_type(::std::string* server_type) {
  if (server_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_type_;
  }
  if (server_type) {
    set_has_server_type();
    server_type_ = server_type;
  } else {
    clear_has_server_type();
    server_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.server_type)
}

// optional string server_host = 4;
inline bool RippleServer_InternalPB::has_server_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RippleServer_InternalPB::set_has_server_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RippleServer_InternalPB::clear_has_server_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RippleServer_InternalPB::clear_server_host() {
  if (server_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_->clear();
  }
  clear_has_server_host();
}
inline const ::std::string& RippleServer_InternalPB::server_host() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.server_host)
  return *server_host_;
}
inline void RippleServer_InternalPB::set_server_host(const ::std::string& value) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
inline void RippleServer_InternalPB::set_server_host(const char* value) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
inline void RippleServer_InternalPB::set_server_host(const char* value, size_t size) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
inline ::std::string* RippleServer_InternalPB::mutable_server_host() {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.server_host)
  return server_host_;
}
inline ::std::string* RippleServer_InternalPB::release_server_host() {
  clear_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_host_;
    server_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_server_host(::std::string* server_host) {
  if (server_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_host_;
  }
  if (server_host) {
    set_has_server_host();
    server_host_ = server_host;
  } else {
    clear_has_server_host();
    server_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.server_host)
}

// optional string server_port = 5;
inline bool RippleServer_InternalPB::has_server_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RippleServer_InternalPB::set_has_server_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RippleServer_InternalPB::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RippleServer_InternalPB::clear_server_port() {
  if (server_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_->clear();
  }
  clear_has_server_port();
}
inline const ::std::string& RippleServer_InternalPB::server_port() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.server_port)
  return *server_port_;
}
inline void RippleServer_InternalPB::set_server_port(const ::std::string& value) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
inline void RippleServer_InternalPB::set_server_port(const char* value) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
inline void RippleServer_InternalPB::set_server_port(const char* value, size_t size) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
inline ::std::string* RippleServer_InternalPB::mutable_server_port() {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.server_port)
  return server_port_;
}
inline ::std::string* RippleServer_InternalPB::release_server_port() {
  clear_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_port_;
    server_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_server_port(::std::string* server_port) {
  if (server_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_port_;
  }
  if (server_port) {
    set_has_server_port();
    server_port_ = server_port;
  } else {
    clear_has_server_port();
    server_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.server_port)
}

// optional string ripple_username = 6;
inline bool RippleServer_InternalPB::has_ripple_username() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RippleServer_InternalPB::set_has_ripple_username() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RippleServer_InternalPB::clear_has_ripple_username() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RippleServer_InternalPB::clear_ripple_username() {
  if (ripple_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_username_->clear();
  }
  clear_has_ripple_username();
}
inline const ::std::string& RippleServer_InternalPB::ripple_username() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
  return *ripple_username_;
}
inline void RippleServer_InternalPB::set_ripple_username(const ::std::string& value) {
  set_has_ripple_username();
  if (ripple_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_username_ = new ::std::string;
  }
  ripple_username_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
inline void RippleServer_InternalPB::set_ripple_username(const char* value) {
  set_has_ripple_username();
  if (ripple_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_username_ = new ::std::string;
  }
  ripple_username_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
inline void RippleServer_InternalPB::set_ripple_username(const char* value, size_t size) {
  set_has_ripple_username();
  if (ripple_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_username_ = new ::std::string;
  }
  ripple_username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
inline ::std::string* RippleServer_InternalPB::mutable_ripple_username() {
  set_has_ripple_username();
  if (ripple_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
  return ripple_username_;
}
inline ::std::string* RippleServer_InternalPB::release_ripple_username() {
  clear_has_ripple_username();
  if (ripple_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ripple_username_;
    ripple_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_ripple_username(::std::string* ripple_username) {
  if (ripple_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ripple_username_;
  }
  if (ripple_username) {
    set_has_ripple_username();
    ripple_username_ = ripple_username;
  } else {
    clear_has_ripple_username();
    ripple_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}

// optional string ripple_password = 7;
inline bool RippleServer_InternalPB::has_ripple_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RippleServer_InternalPB::set_has_ripple_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RippleServer_InternalPB::clear_has_ripple_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RippleServer_InternalPB::clear_ripple_password() {
  if (ripple_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_password_->clear();
  }
  clear_has_ripple_password();
}
inline const ::std::string& RippleServer_InternalPB::ripple_password() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
  return *ripple_password_;
}
inline void RippleServer_InternalPB::set_ripple_password(const ::std::string& value) {
  set_has_ripple_password();
  if (ripple_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_password_ = new ::std::string;
  }
  ripple_password_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
inline void RippleServer_InternalPB::set_ripple_password(const char* value) {
  set_has_ripple_password();
  if (ripple_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_password_ = new ::std::string;
  }
  ripple_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
inline void RippleServer_InternalPB::set_ripple_password(const char* value, size_t size) {
  set_has_ripple_password();
  if (ripple_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_password_ = new ::std::string;
  }
  ripple_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
inline ::std::string* RippleServer_InternalPB::mutable_ripple_password() {
  set_has_ripple_password();
  if (ripple_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ripple_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
  return ripple_password_;
}
inline ::std::string* RippleServer_InternalPB::release_ripple_password() {
  clear_has_ripple_password();
  if (ripple_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ripple_password_;
    ripple_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_ripple_password(::std::string* ripple_password) {
  if (ripple_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ripple_password_;
  }
  if (ripple_password) {
    set_has_ripple_password();
    ripple_password_ = ripple_password;
  } else {
    clear_has_ripple_password();
    ripple_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}

// optional string namefield_id = 8;
inline bool RippleServer_InternalPB::has_namefield_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RippleServer_InternalPB::set_has_namefield_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RippleServer_InternalPB::clear_has_namefield_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RippleServer_InternalPB::clear_namefield_id() {
  if (namefield_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_->clear();
  }
  clear_has_namefield_id();
}
inline const ::std::string& RippleServer_InternalPB::namefield_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
  return *namefield_id_;
}
inline void RippleServer_InternalPB::set_namefield_id(const ::std::string& value) {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  namefield_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
inline void RippleServer_InternalPB::set_namefield_id(const char* value) {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  namefield_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
inline void RippleServer_InternalPB::set_namefield_id(const char* value, size_t size) {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  namefield_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
inline ::std::string* RippleServer_InternalPB::mutable_namefield_id() {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
  return namefield_id_;
}
inline ::std::string* RippleServer_InternalPB::release_namefield_id() {
  clear_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namefield_id_;
    namefield_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_namefield_id(::std::string* namefield_id) {
  if (namefield_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namefield_id_;
  }
  if (namefield_id) {
    set_has_namefield_id();
    namefield_id_ = namefield_id;
  } else {
    clear_has_namefield_id();
    namefield_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}

// optional string passfield_id = 9;
inline bool RippleServer_InternalPB::has_passfield_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RippleServer_InternalPB::set_has_passfield_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RippleServer_InternalPB::clear_has_passfield_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RippleServer_InternalPB::clear_passfield_id() {
  if (passfield_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passfield_id_->clear();
  }
  clear_has_passfield_id();
}
inline const ::std::string& RippleServer_InternalPB::passfield_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
  return *passfield_id_;
}
inline void RippleServer_InternalPB::set_passfield_id(const ::std::string& value) {
  set_has_passfield_id();
  if (passfield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passfield_id_ = new ::std::string;
  }
  passfield_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
inline void RippleServer_InternalPB::set_passfield_id(const char* value) {
  set_has_passfield_id();
  if (passfield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passfield_id_ = new ::std::string;
  }
  passfield_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
inline void RippleServer_InternalPB::set_passfield_id(const char* value, size_t size) {
  set_has_passfield_id();
  if (passfield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passfield_id_ = new ::std::string;
  }
  passfield_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
inline ::std::string* RippleServer_InternalPB::mutable_passfield_id() {
  set_has_passfield_id();
  if (passfield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passfield_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
  return passfield_id_;
}
inline ::std::string* RippleServer_InternalPB::release_passfield_id() {
  clear_has_passfield_id();
  if (passfield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passfield_id_;
    passfield_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RippleServer_InternalPB::set_allocated_passfield_id(::std::string* passfield_id) {
  if (passfield_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passfield_id_;
  }
  if (passfield_id) {
    set_has_passfield_id();
    passfield_id_ = passfield_id;
  } else {
    clear_has_passfield_id();
    passfield_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}

// -------------------------------------------------------------------

// LoomServer_InternalPB

// optional string gui_label = 1;
inline bool LoomServer_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoomServer_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoomServer_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoomServer_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& LoomServer_InternalPB::gui_label() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.gui_label)
  return *gui_label_;
}
inline void LoomServer_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
inline void LoomServer_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
inline void LoomServer_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
inline ::std::string* LoomServer_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gui_label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.gui_label)
  return gui_label_;
}
inline ::std::string* LoomServer_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool LoomServer_InternalPB::has_notary_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoomServer_InternalPB::set_has_notary_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoomServer_InternalPB::clear_has_notary_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoomServer_InternalPB::clear_notary_id() {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_->clear();
  }
  clear_has_notary_id();
}
inline const ::std::string& LoomServer_InternalPB::notary_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.notary_id)
  return *notary_id_;
}
inline void LoomServer_InternalPB::set_notary_id(const ::std::string& value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
inline void LoomServer_InternalPB::set_notary_id(const char* value) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
inline void LoomServer_InternalPB::set_notary_id(const char* value, size_t size) {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  notary_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
inline ::std::string* LoomServer_InternalPB::mutable_notary_id() {
  set_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notary_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.notary_id)
  return notary_id_;
}
inline ::std::string* LoomServer_InternalPB::release_notary_id() {
  clear_has_notary_id();
  if (notary_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = notary_id_;
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_notary_id(::std::string* notary_id) {
  if (notary_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete notary_id_;
  }
  if (notary_id) {
    set_has_notary_id();
    notary_id_ = notary_id;
  } else {
    clear_has_notary_id();
    notary_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}

// optional string server_type = 3;
inline bool LoomServer_InternalPB::has_server_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoomServer_InternalPB::set_has_server_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoomServer_InternalPB::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoomServer_InternalPB::clear_server_type() {
  if (server_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_->clear();
  }
  clear_has_server_type();
}
inline const ::std::string& LoomServer_InternalPB::server_type() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.server_type)
  return *server_type_;
}
inline void LoomServer_InternalPB::set_server_type(const ::std::string& value) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
inline void LoomServer_InternalPB::set_server_type(const char* value) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
inline void LoomServer_InternalPB::set_server_type(const char* value, size_t size) {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  server_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
inline ::std::string* LoomServer_InternalPB::mutable_server_type() {
  set_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.server_type)
  return server_type_;
}
inline ::std::string* LoomServer_InternalPB::release_server_type() {
  clear_has_server_type();
  if (server_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_type_;
    server_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_server_type(::std::string* server_type) {
  if (server_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_type_;
  }
  if (server_type) {
    set_has_server_type();
    server_type_ = server_type;
  } else {
    clear_has_server_type();
    server_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.server_type)
}

// optional string server_host = 4;
inline bool LoomServer_InternalPB::has_server_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoomServer_InternalPB::set_has_server_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoomServer_InternalPB::clear_has_server_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoomServer_InternalPB::clear_server_host() {
  if (server_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_->clear();
  }
  clear_has_server_host();
}
inline const ::std::string& LoomServer_InternalPB::server_host() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.server_host)
  return *server_host_;
}
inline void LoomServer_InternalPB::set_server_host(const ::std::string& value) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
inline void LoomServer_InternalPB::set_server_host(const char* value) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
inline void LoomServer_InternalPB::set_server_host(const char* value, size_t size) {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  server_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
inline ::std::string* LoomServer_InternalPB::mutable_server_host() {
  set_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.server_host)
  return server_host_;
}
inline ::std::string* LoomServer_InternalPB::release_server_host() {
  clear_has_server_host();
  if (server_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_host_;
    server_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_server_host(::std::string* server_host) {
  if (server_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_host_;
  }
  if (server_host) {
    set_has_server_host();
    server_host_ = server_host;
  } else {
    clear_has_server_host();
    server_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.server_host)
}

// optional string server_port = 5;
inline bool LoomServer_InternalPB::has_server_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoomServer_InternalPB::set_has_server_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoomServer_InternalPB::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoomServer_InternalPB::clear_server_port() {
  if (server_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_->clear();
  }
  clear_has_server_port();
}
inline const ::std::string& LoomServer_InternalPB::server_port() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.server_port)
  return *server_port_;
}
inline void LoomServer_InternalPB::set_server_port(const ::std::string& value) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
inline void LoomServer_InternalPB::set_server_port(const char* value) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
inline void LoomServer_InternalPB::set_server_port(const char* value, size_t size) {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  server_port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
inline ::std::string* LoomServer_InternalPB::mutable_server_port() {
  set_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.server_port)
  return server_port_;
}
inline ::std::string* LoomServer_InternalPB::release_server_port() {
  clear_has_server_port();
  if (server_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_port_;
    server_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_server_port(::std::string* server_port) {
  if (server_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_port_;
  }
  if (server_port) {
    set_has_server_port();
    server_port_ = server_port;
  } else {
    clear_has_server_port();
    server_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.server_port)
}

// optional string loom_username = 6;
inline bool LoomServer_InternalPB::has_loom_username() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoomServer_InternalPB::set_has_loom_username() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoomServer_InternalPB::clear_has_loom_username() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoomServer_InternalPB::clear_loom_username() {
  if (loom_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loom_username_->clear();
  }
  clear_has_loom_username();
}
inline const ::std::string& LoomServer_InternalPB::loom_username() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.loom_username)
  return *loom_username_;
}
inline void LoomServer_InternalPB::set_loom_username(const ::std::string& value) {
  set_has_loom_username();
  if (loom_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loom_username_ = new ::std::string;
  }
  loom_username_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
inline void LoomServer_InternalPB::set_loom_username(const char* value) {
  set_has_loom_username();
  if (loom_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loom_username_ = new ::std::string;
  }
  loom_username_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
inline void LoomServer_InternalPB::set_loom_username(const char* value, size_t size) {
  set_has_loom_username();
  if (loom_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loom_username_ = new ::std::string;
  }
  loom_username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
inline ::std::string* LoomServer_InternalPB::mutable_loom_username() {
  set_has_loom_username();
  if (loom_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loom_username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.loom_username)
  return loom_username_;
}
inline ::std::string* LoomServer_InternalPB::release_loom_username() {
  clear_has_loom_username();
  if (loom_username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loom_username_;
    loom_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_loom_username(::std::string* loom_username) {
  if (loom_username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loom_username_;
  }
  if (loom_username) {
    set_has_loom_username();
    loom_username_ = loom_username;
  } else {
    clear_has_loom_username();
    loom_username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}

// optional string namefield_id = 7;
inline bool LoomServer_InternalPB::has_namefield_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoomServer_InternalPB::set_has_namefield_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoomServer_InternalPB::clear_has_namefield_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoomServer_InternalPB::clear_namefield_id() {
  if (namefield_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_->clear();
  }
  clear_has_namefield_id();
}
inline const ::std::string& LoomServer_InternalPB::namefield_id() const {
  // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
  return *namefield_id_;
}
inline void LoomServer_InternalPB::set_namefield_id(const ::std::string& value) {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  namefield_id_->assign(value);
  // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
inline void LoomServer_InternalPB::set_namefield_id(const char* value) {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  namefield_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
inline void LoomServer_InternalPB::set_namefield_id(const char* value, size_t size) {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  namefield_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
inline ::std::string* LoomServer_InternalPB::mutable_namefield_id() {
  set_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namefield_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
  return namefield_id_;
}
inline ::std::string* LoomServer_InternalPB::release_namefield_id() {
  clear_has_namefield_id();
  if (namefield_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namefield_id_;
    namefield_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoomServer_InternalPB::set_allocated_namefield_id(::std::string* namefield_id) {
  if (namefield_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namefield_id_;
  }
  if (namefield_id) {
    set_has_namefield_id();
    namefield_id_ = namefield_id;
  } else {
    clear_has_namefield_id();
    namefield_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OTDB
}  // namespace opentxs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Bitcoin_2eproto__INCLUDED
